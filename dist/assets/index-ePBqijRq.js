(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))s(a);new MutationObserver(a=>{for(const n of a)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function e(a){const n={};return a.integrity&&(n.integrity=a.integrity),a.referrerPolicy&&(n.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?n.credentials="include":a.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(a){if(a.ep)return;a.ep=!0;const n=e(a);fetch(a.href,n)}})();const i={CANVAS_WIDTH:1200,CANVAS_HEIGHT:1200,INTERSECTION_SIZE:120,ROAD_WIDTH:60,LANE_WIDTH:30,CAR_WIDTH:16,CAR_HEIGHT:8,CAR_COLORS:["#FF0000","#00FF00","#0000FF","#FFFF00","#FFA500","#FFFFFF","#000000","#888888"],DIRECTIONS:{NORTH:"north",SOUTH:"south",EAST:"east",WEST:"west"},TURN_TYPES:{STRAIGHT:"straight",LEFT:"left",RIGHT:"right"},MODES:{FIXED:"fixed",ADAPTIVE:"adaptive"},LIGHT_SIZE:12,LIGHT_STATES:{RED:"red",YELLOW:"yellow",GREEN:"green"},DEFAULT_SETTINGS:{GREEN_DURATION:1e5,YELLOW_DURATION:5e3,RED_DURATION:1e5,CAR_SPAWN_RATE:4,CAR_SPEED:25,TURN_RATE:.4,DETECTOR_DISTANCE:500,MIN_GREEN_TIME:5e3},TURN_DELAYS:{LEFT:2e3,RIGHT:1500,STRAIGHT:0},HEADINGS:{NORTH:270,SOUTH:90,EAST:0,WEST:180},ADAPTIVE_SETTINGS:{DETECTOR_DISTANCE_RANGE:[100,500]}};class C{getPathEntryPoint(t){const e=this.roadWidth/2,s=this.laneWidth/2;switch(t){case i.DIRECTIONS.NORTH:return{x:this.centerX-s,y:this.centerY-e};case i.DIRECTIONS.EAST:return{x:this.centerX+e,y:this.centerY-s};case i.DIRECTIONS.SOUTH:return{x:this.centerX+s,y:this.centerY+e};case i.DIRECTIONS.WEST:return{x:this.centerX-e,y:this.centerY+s};default:return{x:this.centerX,y:this.centerY}}}constructor(t,e){this.centerX=t,this.centerY=e,this.size=i.INTERSECTION_SIZE,this.roadWidth=i.ROAD_WIDTH,this.laneWidth=i.LANE_WIDTH,this.calculatePositions()}initialize(){this.calculatePositions()}calculatePositions(){const t=this.size/2,e=this.roadWidth/2,s=this.laneWidth/2,a=t+5;this.stopLines={[i.DIRECTIONS.NORTH]:{x1:this.centerX-e,y1:this.centerY-a,x2:this.centerX+e,y2:this.centerY-a},[i.DIRECTIONS.EAST]:{x1:this.centerX+a,y1:this.centerY-e,x2:this.centerX+a,y2:this.centerY+e},[i.DIRECTIONS.SOUTH]:{x1:this.centerX-e,y1:this.centerY+a,x2:this.centerX+e,y2:this.centerY+a},[i.DIRECTIONS.WEST]:{x1:this.centerX-a,y1:this.centerY-e,x2:this.centerX-a,y2:this.centerY+e}},this.lightPositions={[i.DIRECTIONS.NORTH]:{x:this.centerX-25,y:this.centerY-t-40},[i.DIRECTIONS.EAST]:{x:this.centerX+t+15,y:this.centerY-25},[i.DIRECTIONS.SOUTH]:{x:this.centerX+25,y:this.centerY+t+15},[i.DIRECTIONS.WEST]:{x:this.centerX-t-40,y:this.centerY+25}},this.spawnPoints={[i.DIRECTIONS.NORTH]:{x:this.centerX-s,y:0},[i.DIRECTIONS.EAST]:{x:i.CANVAS_WIDTH,y:this.centerY-s},[i.DIRECTIONS.SOUTH]:{x:this.centerX+s,y:i.CANVAS_HEIGHT},[i.DIRECTIONS.WEST]:{x:0,y:this.centerY+s}},this.updateSpawnPointsForLanes(),this.exitPoints={[i.DIRECTIONS.NORTH]:{x:this.centerX+s,y:0},[i.DIRECTIONS.EAST]:{x:i.CANVAS_WIDTH,y:this.centerY+s},[i.DIRECTIONS.SOUTH]:{x:this.centerX-s,y:i.CANVAS_HEIGHT},[i.DIRECTIONS.WEST]:{x:0,y:this.centerY-s}}}updateSpawnPointsForLanes(){const t=this.laneWidth/2;this.spawnPointsByLane={[i.DIRECTIONS.NORTH]:[{x:this.centerX-t,y:0},{x:this.centerX+t,y:i.CANVAS_HEIGHT}],[i.DIRECTIONS.EAST]:[{x:i.CANVAS_WIDTH,y:this.centerY-t},{x:0,y:this.centerY+t}],[i.DIRECTIONS.SOUTH]:[{x:this.centerX+t,y:i.CANVAS_HEIGHT},{x:this.centerX-t,y:0}],[i.DIRECTIONS.WEST]:[{x:0,y:this.centerY+t},{x:i.CANVAS_WIDTH,y:this.centerY-t}]}}getSpawnPointForLane(t,e){return this.spawnPointsByLane[t]?this.spawnPointsByLane[t][e]:this.spawnPoints[t]}render(t){this.drawRoads(t),this.drawIntersection(t),this.drawLaneMarkings(t),this.drawStopLines(t)}drawRoads(t){const e=this.roadWidth/2;t.fillStyle="#444444",t.fillRect(this.centerX-e,0,this.roadWidth,i.CANVAS_HEIGHT),t.fillRect(0,this.centerY-e,i.CANVAS_WIDTH,this.roadWidth)}drawIntersection(t){const e=this.roadWidth/2,s=e;t.fillStyle="#666666",t.beginPath(),t.moveTo(this.centerX-e,this.centerY-e-s),t.quadraticCurveTo(this.centerX-e,this.centerY-e,this.centerX-e-s,this.centerY-e),t.lineTo(this.centerX-e-s,this.centerY+e),t.quadraticCurveTo(this.centerX-e,this.centerY+e,this.centerX-e,this.centerY+e+s),t.lineTo(this.centerX+e,this.centerY+e+s),t.quadraticCurveTo(this.centerX+e,this.centerY+e,this.centerX+e+s,this.centerY+e),t.lineTo(this.centerX+e+s,this.centerY-e),t.quadraticCurveTo(this.centerX+e,this.centerY-e,this.centerX+e,this.centerY-e-s),t.closePath(),t.fill(),t.globalCompositeOperation="source-over"}drawLaneMarkings(t){t.strokeStyle="#ffffff",t.lineWidth=2,t.setLineDash([10,10]);const e=this.roadWidth/2;t.beginPath(),t.moveTo(this.centerX,0),t.lineTo(this.centerX,this.centerY-e),t.moveTo(this.centerX,this.centerY+e),t.lineTo(this.centerX,i.CANVAS_HEIGHT),t.stroke(),t.beginPath(),t.moveTo(0,this.centerY),t.lineTo(this.centerX-e,this.centerY),t.moveTo(this.centerX+e,this.centerY),t.lineTo(i.CANVAS_WIDTH,this.centerY),t.stroke(),t.setLineDash([])}drawStopLines(t){t.strokeStyle="#ffffff",t.lineWidth=4,Object.values(this.stopLines).forEach(e=>{t.beginPath(),t.moveTo(e.x1,e.y1),t.lineTo(e.x2,e.y2),t.stroke()})}getStopLinePosition(t){return this.stopLines[t]}getSpawnPoint(t){switch(t){case"north":return{x:this.centerX,y:this.centerY-300};case"south":return{x:this.centerX,y:this.centerY+300};case"east":return{x:this.centerX+300,y:this.centerY};case"west":return{x:this.centerX-300,y:this.centerY};default:return}}getExitPoint(t){switch(t){case"north":return{x:this.centerX,y:this.centerY-300};case"south":return{x:this.centerX,y:this.centerY+300};case"east":return{x:this.centerX+300,y:this.centerY};case"west":return{x:this.centerX-300,y:this.centerY};default:return}}getLightPosition(t){if(!t||typeof t!="string"){console.warn("Invalid direction for getLightPosition:",t);return}return this.lightPositions[t]}isInIntersection(t,e){const s=this.roadWidth/2;return t>=this.centerX-s&&t<=this.centerX+s&&e>=this.centerY-s&&e<=this.centerY+s}getProperExitPoint(t,e,s){return this.laneWidth/2,this.exitPoints[e]}getTurningPath(t,e,s){return[this.getPathEntryPoint(t),this.exitPoints[e]]}getPathEntryPoint(t){const e=this.roadWidth/2,s=this.laneWidth/2;switch(t){case i.DIRECTIONS.NORTH:return{x:this.centerX-s,y:this.centerY-e};case i.DIRECTIONS.EAST:return{x:this.centerX+e,y:this.centerY-s};case i.DIRECTIONS.SOUTH:return{x:this.centerX+s,y:this.centerY+e};case i.DIRECTIONS.WEST:return{x:this.centerX-e,y:this.centerY+s}}}setCarManager(t){this.carManager=t}getAllCars(){return this.carManager?this.carManager.getCars():[]}}class g{initialize(t,e){this.mode=t,this.settings={...e},t===i.MODES.FIXED?this.initializeFixedMode():t===i.MODES.ADAPTIVE&&this.initializeAdaptiveMode()}constructor(){this.lights={},this.mode=i.MODES.FIXED,this.settings={...i.DEFAULT_SETTINGS},this.fixedState={currentPhase:0,phaseTimer:0,isActive:!1},this.adaptiveState={currentPair:null,currentPhase:"red",phaseTimer:0,isActive:!1,priorityScores:{WE:0,NS:0},lastSwitchTime:0,firstCarTriggered:!1},this.initializeLights()}initializeLights(){Object.values(i.DIRECTIONS).forEach(t=>{this.lights[t]={state:i.LIGHT_STATES.RED,timer:0}})}initializeFixedMode(){console.log("Initializing Fixed Mode"),this.fixedState={currentPhase:0,phaseTimer:0,isActive:!0},this.setFixedLightState()}initializeAdaptiveMode(){console.log("Initializing Adaptive Mode"),this.adaptiveState={currentPair:null,currentPhase:"red",phaseTimer:0,isActive:!0,priorityScores:{WE:0,NS:0},lastSwitchTime:0,firstCarTriggered:!1},this.setAllLightsRed()}update(t,e,s){this.mode=e,this.settings={...s},e===i.MODES.FIXED?(this.fixedState.isActive||this.initializeFixedMode(),this.updateFixedMode(t)):e===i.MODES.ADAPTIVE&&(this.adaptiveState.isActive||this.initializeAdaptiveMode(),this.updateAdaptiveMode(t))}updateFixedMode(t){switch(this.fixedState.phaseTimer+=t,this.fixedState.currentPhase){case 0:this.fixedState.phaseTimer>=this.settings.GREEN_DURATION&&this.advanceFixedPhase();break;case 1:this.fixedState.phaseTimer>=this.settings.YELLOW_DURATION&&this.advanceFixedPhase();break;case 2:this.fixedState.phaseTimer>=3e3&&this.advanceFixedPhase();break;case 3:this.fixedState.phaseTimer>=this.settings.GREEN_DURATION&&this.advanceFixedPhase();break;case 4:this.fixedState.phaseTimer>=this.settings.YELLOW_DURATION&&this.advanceFixedPhase();break;case 5:this.fixedState.phaseTimer>=3e3&&this.advanceFixedPhase();break}}advanceFixedPhase(){this.fixedState.currentPhase=(this.fixedState.currentPhase+1)%6,this.fixedState.phaseTimer=0,this.setFixedLightState(),console.log(`Fixed Mode: Advanced to phase ${this.fixedState.currentPhase}`)}setFixedLightState(){switch(this.setAllLightsRed(),this.fixedState.currentPhase){case 0:this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.GREEN;break;case 1:this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.YELLOW,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.YELLOW;break;case 2:break;case 3:this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.GREEN;break;case 4:this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.YELLOW,this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.YELLOW;break}}updateAdaptiveMode(t){if(this.adaptiveState.phaseTimer+=t,this.adaptiveState.currentPair===null){const e=this.getHighestPriorityPair();e&&this.adaptiveState.priorityScores[e]>0&&(console.log(`Adaptive Mode: First car detected, switching to ${e}`),this.switchToAdaptivePair(e));return}switch(this.adaptiveState.currentPhase){case"green":this.shouldSwitchInAdaptive()&&(console.log("Adaptive Mode: Switching due to higher priority"),this.startAdaptiveYellow());break;case"yellow":this.adaptiveState.phaseTimer>=this.settings.YELLOW_DURATION&&this.startAdaptiveRed();break;case"red
